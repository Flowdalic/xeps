<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY signcrypt "&lt;signcrypt/&gt;">
  <!ENTITY openpgp "&lt;openpgp/&gt;">
  <!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
  <title>OpenPGP for XMPP</title>
  <abstract>Secifies end-to-end encryption for data with the help of
  OpenPGP, annoucement, discovery and retrieval of public keys and a
  mechanism to synchronize secret keys over multiple
  devices.</abstract>
  <legal>
    <copyright>This XMPP Extension Protocol is copyright (c) 1999 - 2014 by the XMPP Standards Foundation (XSF).</copyright>
    <permissions>Permission is hereby granted, free of charge, to any person obtaining a copy of this specification (the &quot;Specification&quot;), to make use of the Specification without restriction, including without limitation the rights to implement the Specification in a software program, deploy the Specification in a network service, and copy, modify, merge, publish, translate, distribute, sublicense, or sell copies of the Specification, and to permit persons to whom the Specification is furnished to do so, subject to the condition that the foregoing copyright notice and this permission notice shall be included in all copies or substantial portions of the Specification. Unless separate permission is granted, modified works that are redistributed shall not contain misleading information regarding the authors, title, number, or publisher of the Specification, and shall not claim endorsement of the modified works by the authors, any organization or project to which the authors belong, or the XMPP Standards Foundation.</permissions>
    <warranty>## NOTE WELL: This Specification is provided on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. In no event shall the XMPP Standards Foundation or the authors of this Specification be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the Specification or the implementation, deployment, or other use of the Specification. ##</warranty>
    <liability>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall the XMPP Standards Foundation or any author of this Specification be liable for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising out of the use or inability to use the Specification (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if the XMPP Standards Foundation or such author has been advised of the possibility of such damages.</liability>
    <conformance>This XMPP Extension Protocol has been contributed in full conformance with the XSF's Intellectual Property Rights Policy (a copy of which may be found at &lt;<link url='http://xmpp.org/extensions/ipr-policy.shtml'>http://xmpp.org/extensions/ipr-policy.shtml</link>&gt; or obtained by writing to XSF, P.O. Box 1641, Denver, CO 80201 USA).</conformance>
  </legal>
  <number>xxxx</number>
  <status>ProtoXEP</status>
  <type>Standards Track</type>
  <sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>XEP-0030</spec>
    <spec>XEP-0049</spec>
    <spec>XEP-0082</spec>
    <spec>XEP-0163</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>opgp</shortname>
  <author>
    <firstname>Florian</firstname>
    <surname>Schmaus</surname>
    <email>flo@geekplace.eu</email>
    <jid>flo@geekplace.eu</jid>
  </author>
  <author>
    <firstname>Dominik</firstname>
    <surname>Schürman</surname>
    <email>dominik@dominikschuermann.de</email>
    <jid>dominik@dominikschuermann.de</jid>
  </author>
  <author>
    <firstname>Vincent</firstname>
    <surname>Breitmoser</surname>
    <email>look@my.amazin.horse</email>
    <jid>valodim@stratum0.org</jid>
  </author>
  <revision>
    <version>0.0.1alpha1</version>
    <date>2016-11-16</date>
    <initials>fs</initials>
    <remark><p>First draft.</p></remark>
  </revision>
</header>
<section1 topic='Introduction' anchor='intro'>
  <p>This XMPP extension protocol specifies end-to-end encryption for
  data with the help of OpenPGP.</p>
  <p>Furthermore XMPP provides the mechanisms to solve a lot of issues
  that come with modern day OpenPGP usage. PEP provides a standardizes
  way to discovery OpenPGP public keys of other entities while, unlike
  the OpenPGP keyserver, establishing a strong relation between the
  key and the user, and Private XML Storage allows for easy OpenPGP
  key synchronization accross devices (of the same XMPP
  entity). OpenPGP in return allows for end-to-end encrypted data to
  be exchanged between one, two or even multiple entities.</p>
  <p>Unlike to similar XEPs, e.g. OMEMO, this XEP <em>does not</em>
  provide Perfect Forward Secrecy (PFS), but as advantage, allows
  users to read their archived converstaions, or, in gernal, their
  encrypted data, later on (as long as they still posses the according
  secret key). Perfect Forward Secrecy and being able to decrypt
  archived messages are mutually exclusive, i.e. one can not have
  both. We therefore consider this XEP complementary to similar ones
  which also provide end-to-end encryption but with a different
  feature set.</p>
  <p>The method defined herin can be used to implement end-to-end
  encrypted Multi-User Chats (&xep0045;).</p>
</section1>
<section1 topic='Requirements' anchor='reqs'>
  <p>STRONGLY RECOMMENDED.</p>
</section1>
<section1 topic='Glossary' anchor='glossary'>
  <dl>
	<di><dt>Public key PEP node</dt><dd>TOOD TODO TODO.</dd></di>
	<di><dt>Secret key PEP node</dt><dd>TOOD TODO TODO.</dd></di>
  </dl>
</section1>
<section1 topic='Use Cases' anchor='usecases'>
  <section2 topic='Discovering Support' anchor='disco'>
	<p>If an entity supports OpenPGP for XMPP as specified herin, it
	MUST report that fact by including a service discovery feature of
	'urn:xmpp:openpgp:0' in response to a &xep0030; information
	request.</p>
  <example caption="Service Discovery information request"><![CDATA[
<iq type='get'
    from='juliet@example.org/balcony'
    to='romeo@example.org/orchard'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>]]></example>
  <example caption="Service Discovery information response"><![CDATA[
<iq type='result'
    from='romeo@example.org/orchard'
    to='juliet@example.org/balcony'
    id='disco1'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    ...
    <feature var='urn:xmpp:openpgp:0'/>
    ...
  </query>
</iq>]]></example>
  </section2>
  <section2 topic='Announcing the public key via PEP' anchor='annoucing-pubkey'>
	<p>In order to annouce the public key, the client needs to store
	it in a &xep0163; node. The public key data, as specified in
	&rfc4880;, is stored within a &lt;pubkey/&gt; element which is a
	child element of the &lt;pubkeys/&gt; qualified by the
	'urn:xmpp:openpgp:0' namespace. Note that OpenPGP's ASCII armor is
	not used, instead the XMPP client MUST encode the public key using
	Base64. Client SHOULD only try to store the public key if the
	Personal Eventing Protocol service supports persistent-items, thus
	it SHOULD check if the service reports the
	'http://jabber.org/protocol/pubsub#persistent-items' feature.</p>
	<example caption='Saving the public key in the Personal Eventing Protocol node.'><![CDATA[
<iq from='juliet@example.org/balcony' type='set' id='1'>
  <pubsub>
     <publish node='urn:xmpp:openpgp:0'>
        <item>
          <pubkeys xmlns='urn:xmpp:openpgp:0'>
            <pubkey>
              <!-- BASE64_OPENPGP_PUBLIC_KEY -->
              YWJjMTIzIT8kK...
            </pubkey>
          </pubkeys>
         </item>
      </publish>
    </pubsub>
</iq>]]></example>
  <p>In order to discover the public key of an XMPP entity, clients
  send a PubSub &IQ; request to the entity's bare JID of which it
  wants to know the public key.</p>
  <example caption='Requesting a OpenPGP public key from a XMPP entity.'><![CDATA[
<iq from='romeo@example.org/orchard' to='juliet@example.org' type='get' id='2'>
  <pubsub>
    <items node='urn:xmpp:openpgp:0' max_items='1'/>
  </pubsub>
</iq>]]></example>
  <example caption='Personal Eventing Protocol result containing the requested public key.'><![CDATA[
<iq from='juliet@example.org' to='romeo@example.org/orchard' type='result' id='2'>
  <pubsub>
    <publish node='urn:xmpp:openpgp:0'>
      <item>
        <pubkeys xmlns='urn:xmpp:openpgp:0'>
          <pubkey>
            <!-- BASE64_OPENPGP_PUBLIC_KEY -->
            YWJjMTIzIT8kK...
          </pubkey>
        </pubkeys>
      </item>
    </publish>
  </pubsub>
</iq>]]></example>
  <p>Note that the result may contain multiple pubkeys elements. Only
  the public keys found in the most recent MUST be used. Requestors
  may want to limit the results to the most recent item using the
  'max_items' attribute set to '1'. (Note: RSM would be an alternative
  but XEP-60 says it is not yet mandatory).</p>
  <p>Some XMPP services may not provide the Personal Eventing Protocol feature required to
  provide the mechanism described here. If so, they will return an
  &IQ; error of type service-unavailable.</p>
  </section2>
  <section2 topic='Encrypted and signed data' anchor='signcrypt'>
	<p>The &openpgp; extension element qualified by the
	'urn:xmpp:openpgp:0' namespace is used in order to exchange
	encrypted and signed data.</p>
	<example caption='The &openpgp; extension within a message.'><![CDATA[
<message to='user@example.org'>
  <openpgp xmlns='urn:xmpp:openpgp:0'>
    <!-- BASE64_OPENPGP_MESSAGE -->
    WdC81xuET8kAK...
  </openpgp>
</message>]]></example>
	<p>The text content of the &openpgp; element (BASE64_OPENPGP_MESSAGE)
	is a Base64 encoded OpenPGP message which contains
	an encrypted and signed UTF-8 encoded string. Note
	that OpenPGP's ASCII armor is not used, instead the XMPP client
	MUST encode the raw OpenPGP message using Base64. This string
	represents a &signcrypt; extension element. It SHOULD also be
	encrypted to self. Encryption is REQUIRED and signing the data is
	RECOMMENDED.</p>
	<example caption='The &signcrypt; extension element.'><![CDATA[
<signcrypt xmlns='urn:xmpp:openpgp:0'
           to='juliet@example.org'
           timestamp='2014-07-10T17:06:00+02:00'>
  <body xmlns='jabber:client'>
    This is a secret message.
  </body>
</signcrypt>]]></example>
	<p>The &signcrypt; element MUST posses at least one 'to' and
	exactly one 'timestamp' attribute. The 'to' element(s) MUST
	contain the intended recipient's XMPP address of the signed and
	encrypted data to prevent Surreptitious Forward Attacks. The XMPP
	address found in the 'to' attribute SHOULD be without Resourcepart
	(i.e. a bare JID). The 'timestamp' attribute contains the
	timestamp when the &signcrypt; element was signed and encrypted in
	the DateTime format as specified in &xep0082; § 3.2. Recipients
	are RECOMMENDED to verify the values of these two elements for
	plausability or to display them to a user for verification.</p>
	<p>Child elements of signcryt can be any extension element. The
	example uses the body element as defined in &rfc6121; § 5.2.3. Note
	that this example uses the 'jabber:client' namespace, but beware
	that the same 'body' element is also defined in the
	'jabber:server' namespace.</p>
	<p>Recipients MUST verify that the signature corresponds to the
	sending XMPP address's key. Thus the recipient may has to
	retrieve the key from the Personal Eventing Protocol node as described above.</p>
  </section2>
  <section2 topic='Synchronizing the secret key with a private PEP node' anchor='synchro-pep'>
	<p>TODO: Basically same as when using Private XML Storage just
	with a private PEP node. Where private PEP node means, a PEP node
	in whitelist mode where only the bare JID of the users is
	whitelisted.</p>
	<section3 topic='Required PEP features'>
	  <p>The users server MUST support PEP, persistent nodes and the whitelist access model</p>
	  <section4 topic='Discovering support'>
	  </section4>
	</section3>
	<section3 topic='Requesting information about the secret key PEP node' anchro='req-info-secret-pep-node'>
	  <p>In order to synchronize the secret key over a private PEP node,
	  clients first need to discover and verify the node for the correct
	  settings.</p>
	  <section4 topic='Client sends request'>
		<example caption='Client requests node'><![CDATA[
		]]></example>
	  </section4>
	  <section4 topic='PEP service success response'>
		<example caption='Client requests node'><![CDATA[
		]]></example>
	  </section4>
	  <section4 topic='PEP node does not exist response'>
	  </section4>
	  <section4 topic='PEP not supported'>
	  </section4>
	  <p>If the node does not exist, the client MUST create it with an
	  whitelist access model.</p>
	</section3>
	<section3 topic='Creating the secret key PEP node'>
	  <example caption='Client creates secret key PEP node'><![CDATA[
<iq type='set'
    from='juliet@example.org/balcony'
    id='create-node'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub'>
      <create node='urn:xmpp:openpgp:secret-key:0'/>
      <configure>
        <x xmlns='jabber:x:data' type='submit'>
          <field var='FORM_TYPE' type='hidden'>
            <value>http://jabber.org/protocol/pubsub#node_config</value>
          </field>
          <field var='pubsub#access_model'><value>whitelist</value></field>
        </x>
      </configure>
    </pubsub>
</iq>]]></example>
	  <example caption='Service informs requesting entity of success'><![CDATA[
<iq type='result'
    to='juliet@example.org/balcony'
    id='create-node'/>]]></example>
	  <p>The node is now created and the only affiliated entity is the
	  bare JID of the user, who created the node, with an affiliation as
	  'owner'. TODO is this correct?</p>
	</section3>
  </section2>
</section1>
<section1 topic='Rationale' anchor='rationale'>
  <p>This specificaiton leaves it open if the used OpenPGP key should
  be a primary key or a subkey. It's even possible to announce
  multiple public keys in the Personal Eventing Protocol
  node. Implementations MUST be prepared to find multiple public
  keys. The authors however believe that for ease of use only one
  OpenPGP key specially crafted for the XMPP uses case should be
  created.</p>
  <p>The &openpgp; and &signcrypt; elements are container for
  arbitrary signed and encrypted data and can thus act as building
  block for encrypting data for Message, IQ and Presence stanzas.</p>
  <p>Note that signed OpenPGP messages already contains a timestamp as per
  the OpenPGP specification. The &signcrypt; element nevertheless
  contains a mandatory 'timestamp' attribute because not every OpenPGP
  API may provide access to the embedded OpenPGP timestamp.</p>
  <section2 topic='Addressing the issues and problems of XEP-0027' anchor='solving-xep0027-issues'>
	<p>This specification addresses all relevant issues of
	XEP-0027. It prevents reply attacks my including the recipient(s)
	and a timestamp in the &signcrypt; element. It allows for both,
	signing and encrypting of the &signcrypt; element. On the other
	hand, the scope of the specification was intentionally limited to
	OpenPGP only.</p>
	<p>Features like signed presences, which is provided by XEP-0027,
	may be added later on as add-on XEP to this.</p>
  </section2>
  <section2 topic='Possible Alternative: Synchronizing the secret key via Private XML Storage' anchor='synchro-private-xml'>
	<p>To allow new XMPP clients to easily retrieve (and eventually
	update) the secret key, &xep0049; is used as synchronization
	mechanism. The secret key MUST be a OpenPGP symmetrically encrypted
	message with a backup code.</p>
	<p>TODO describe format as per
	https://github.com/open-keychain/open-keychain/wiki/Backups)</p>
	<p>In order to set a new secret key, clients store the encrypted
	backup key as Base64 encoded raw OpenPGP message within an
	&lt;secretkey/&gt; element qualified by the 'urn:xmpp:openpgp:0'
	namespace.</p>
    <example caption='Client stores backup key in private XML storage.'><![CDATA[
<iq type='set' id='priv1'>
  <query xmlns='jabber:iq:private'>
    <secretkey xmlns='urn:xmpp:openpgp:0'/>
      <!-- BASE64_OPENPGP_ENCRYPTED_SECRET_KEY -->
      8afaqse73adf...
    </secretkey>
  </query>
</iq>]]></example>
	<p>New clients then later can retrieve the stored encrypted secret key.</p>
    <example caption='Client retrieves encrypted secret key from private XML storage.'><![CDATA[
<iq type='get' id='priv2'>
  <query xmlns='jabber:iq:private'>
    <secretkey xmlns='urn:xmpp:openpgp:0'/>
  </query>
  </iq>]]></example>
    <example caption='Client Stores Private Data'><![CDATA[
<iq type='result' id='priv2'>
  <query xmlns='jabber:iq:private'>
    <secretkey xmlns='urn:xmpp:openpgp:0'>
      <!-- BASE64_OPENPGP_ENCRYPTED_SECRET_KEY -->
      8afaqse73adf...
    </secretkey>
  </query>
</iq>]]></example>
  </section2>
</section1>
<section1 topic='Security Considerations' anchor='security'>
  <p>The scope of this XEP is intentionally limited, so that the
  specification just defines way for XMPP entities to discover,
  announce and synchronize OpenPGP keys, and how to exchange signed
  and encrypted data between two or more parties. Everything else is
  outside its scope. For example, how "secure' the key material on the
  endpoints is protected, is up to the implementation.</p>
  <p>And while this XEP specifies a mechanism how to discover and
  retrieve a public key, it does not define how the trust relation to
  this key should be established. Even if key discovery and retrieval
  over XMPP provides a stronger coupling between the possessing entity
  (the XMPP address) and the key, as compared to the OpenPGP keyservers,
  how a XMPP server authenticates a remote server is a server policy,
  which does vary from server to server. Implementation MUST provide a
  way for the user to establish and assign trust to a public key. For
  example by using a QR code shown on the other user's device's
  screen.</p>
</section1>
<section1 topic='IANA Considerations' anchor='iana'>
  <p>This document requires no interaction with &IANA;.</p>
</section1>
<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
  <section2 topic='Protocol Namespaces' anchor='registrar-ns'>
    <p>The &REGISTRAR; includes 'urn:xmpp:openpgp:0' in its registry of protocol namespaces (see &NAMESPACES;).</p>
  </section2>
</section1>
<section1 topic='XML Schema' anchor='schema'>
  <p>REQUIRED for protocol specifications.</p>
</section1>
<section1 topic='Acknowledgements' anchor='acknowledgements'>
  <p>The first draft of this specification was worked out and written
  on the wall of the 'Kymera' room in one of Google's buildings by the
  authors, consisting of members of the XMPP Standards Foundation and
  the OpenKeychain project, at the GSOC Mentors Summit 2015. The
  authors would like to thank Google for making it possible by
  bringing the right people together.</p>
</section1>
</xep>
